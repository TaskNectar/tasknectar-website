<!DOCTYPE html>
<html lang="en">
<head>
   <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-GYJSNCR46K"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-GYJSNCR46K');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7609988011266328"
     crossorigin="anonymous"></script>
  <meta charset="utf-8">
  <title>PDF Merger | TaskNectar</title>
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta content="" name="keywords">
  <meta content="" name="description">
<meta name="title" content="Free PDF Merger Online | Merge PDFs Fast & Easily - TaskNectar">
<meta name="description" content="Combine multiple PDF files into one seamless document with TaskNectar's free online PDF Merger. Drag & drop, reorder, and merge PDFs instantly—no sign-up required. Perfect for freelancers and small businesses.">
<meta name="keywords" content="PDF Merger, merge PDFs online, combine PDF files, free PDF tool, online PDF merger, PDF merging tool, merge PDF documents, TaskNectar PDF merger">
<meta name="robots" content="index, follow">

  <!-- Favicon -->
  <link href="/img/favicon.png" rel="icon">

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500&family=Roboto:wght@500;700&display=swap" rel="stylesheet">

  <!-- Icon Font Stylesheet -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.0/css/all.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.4.1/font/bootstrap-icons.css" rel="stylesheet">

  <!-- Bootstrap & Template Stylesheet -->
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/style.css" rel="stylesheet">
  <!-- jQuery first -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

<!-- Bootstrap JS bundle -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<!-- Your main.js -->
<script src="/js/main.js"></script>

<style>
    :root{
      --bg:#fff7ed; /* soft yellow */
      --accent:#EFB301; /* user's requested yellow */
      --text:#000;
      --ui-radius:10px;
      --panel-width:360px;
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Arial; color:var(--text); background:var(--bg)}
    .app{display:flex;gap:18px;padding:18px;box-sizing:border-box;height:100%}
    /* Left column: controls */
    .controls{width:var(--panel-width);background:linear-gradient(180deg,#fff,#fffef8);border-radius:var(--ui-radius);padding:16px;box-shadow:0 6px 18px rgba(0,0,0,0.06);display:flex;flex-direction:column;gap:12px}
    .controls h2{margin:0;font-size:18px}
    .file-drop{border:2px dashed rgba(0,0,0,0.08);padding:12px;border-radius:8px;text-align:center;background:transparent}
    input[type=file]{display:block;margin-top:8px}
    .tools{display:flex;flex-wrap:wrap;gap:8px}
    .btn{background:var(--accent);border:none;color:#000;padding:8px 12px;border-radius:999px;cursor:pointer;font-weight:600}
    .btn.secondary{background:#fff;border:1px solid rgba(0,0,0,0.08)}
    .tool-option{padding:8px 10px;border-radius:8px;border:1px solid transparent;cursor:pointer}
    .tool-option.active{border-color:rgba(0,0,0,0.12);background:rgba(0,0,0,0.02)}
    label{font-size:13px}
    .row{display:flex;gap:8px;align-items:center}
    .color-sample{width:28px;height:28px;border-radius:6px;border:1px solid rgba(0,0,0,0.06)}
    .pages{flex:1;overflow:auto;border-radius:var(--ui-radius);padding:12px;background:linear-gradient(180deg,#fff,#fffef8);box-shadow:0 6px 18px rgba(0,0,0,0.04)}
    .page{position:relative;margin:12px auto;max-width:900px;}
    canvas.pdf-canvas{display:block;width:100%;height:auto;border-radius:6px;box-shadow:0 4px 12px rgba(0,0,0,0.06)}
    .annotation-layer{position:absolute;left:0;top:0;width:100%;height:100%;touch-action:none}
    .toolbar-small{display:flex;gap:6px;flex-wrap:wrap}
    .footer-hint{font-size:12px;color:rgba(0,0,0,0.5)}
    /* Responsive */
    @media (max-width:900px){
      .app{flex-direction:column}
      .controls{width:100%;order:2}
      .pages{order:1}
    }
  </style>
</head>
<body>
      <!-- Header Include -->
  <div data-include="/header.html"></div>
<section class="hero-content">
  <div class="hero-content-content">
    <h1>Merge PDFs Seamlessly</h1>
    <p>Drag and drop your PDF files, reorder them as needed, and merge into one file instantly. No sign-up needed, no fuss.</p>
    <p><i>For best results, use on desktop</i></p>
  </div>
</section>
<section class="hero-content" style="background-color: #fff; max-width: 1320px; margin: 2rem auto; padding: 0 1rem;">
  <h2 style="font-size: 1.5rem; font-weight: bold; color: #000!important;">Combine Multiple PDFs Quickly & Easily — Free, Fast & Reliable</h2>
  <p style="margin-top: 1rem; font-size: 1.1rem; color: #000!important;">
    Our TaskNectar PDF Merger lets you upload multiple PDF files, reorder them by dragging, and merge them into a single professional document in seconds — no account required, no software to install.
  </p>
  <p style="margin-top: 1rem; font-size: 1.1rem; color: #000!important;">
    Perfect for freelancers, small businesses, or anyone needing to consolidate reports, invoices, contracts, or presentations effortlessly. Simply upload your PDFs, arrange the order, and download your merged file.
  </p>
  <br />
</section>
<br />
  <div class="app">
    <aside class="controls">
      <h2>PDF Editor</h2>
      <div class="file-drop" id="dropzone">
        <div>Drop a PDF here or</div>
        <input id="fileInput" type="file" accept="application/pdf">
        <div id="filename" style="font-size:13px;color:rgba(0,0,0,0.6);margin-top:8px"></div>
      </div>

      <div>
        <label>Tools</label>
        <div class="tools toolbar-small">
          <button class="btn tool-option active" data-tool="pan">Pan</button>
          <button class="tool-option" data-tool="text">Text</button>
          <button class="tool-option" data-tool="draw">Draw</button>
          <button class="tool-option" data-tool="highlight">Highlight</button>
          <button class="tool-option" data-tool="erase">Erase</button>
        </div>
      </div>

      <div class="row">
        <div style="flex:1">
          <label>Color</label>
          <input id="color" type="color" value="#ffb300" style="display:block;margin-top:6px">
        </div>
        <div style="width:86px">
          <label>Size</label>
          <input id="size" type="range" min="1" max="60" value="4" style="width:100%">
        </div>
      </div>

      <div class="row">
        <button id="undoBtn" class="btn secondary">Undo</button>
        <button id="clearBtn" class="btn secondary">Clear Page</button>
      </div>

      <div class="row">
        <button id="saveBtn" class="btn">Save PDF</button>
        <button id="exportImagesBtn" class="btn secondary">Export as Images</button>
      </div>

      <div style="margin-top:6px;font-size:13px;color:rgba(0,0,0,0.6)">
        <div>Notes:</div>
        <div class="footer-hint">This editor renders pages in-browser and merges your annotations into the PDF on export. Text/draw are rasterized — good for signing, annotating, stamping.</div>
      </div>
    </aside>

    <main class="pages" id="pages">
      <div style="text-align:center;color:rgba(0,0,0,0.45);padding:40px" id="emptyState">No PDF loaded — upload or drop a PDF file to get started.</div>
    </main>
  </div>

  <script>
  // --------- Basic PDF editor using PDF.js (render) + pdf-lib (export) ---------
  // Features implemented:
  // - Upload & render PDF pages to canvases
  // - Annotation layer for each page (drawing and text)
  // - Undo, clear page
  // - Export final PDF with annotations flattened onto pages (raster approach)
  
  // External libraries expected: pdf.js (window['pdfjsLib']) and PDFLib (window.PDFLib)
  (function(){
    const pdfjsLib = window['pdfjsLib'];
    const { PDFDocument } = window.PDFLib;

    // configure worker (cdn path may vary) - attempt to set to same origin CDN
    if (pdfjsLib.GlobalWorkerOptions) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    }

    // UI refs
    const fileInput = document.getElementById('fileInput');
    const dropzone = document.getElementById('dropzone');
    const pagesEl = document.getElementById('pages');
    const emptyState = document.getElementById('emptyState');
    const filenameEl = document.getElementById('filename');

    const toolButtons = document.querySelectorAll('.tool-option');
    const colorInput = document.getElementById('color');
    const sizeInput = document.getElementById('size');
    const undoBtn = document.getElementById('undoBtn');
    const clearBtn = document.getElementById('clearBtn');
    const saveBtn = document.getElementById('saveBtn');
    const exportImagesBtn = document.getElementById('exportImagesBtn');

    let currentTool = 'pan';
    let docPages = []; // array of page objects {pdfPage, scale, viewport, canvas, annCanvas, annCtx, actions:[]}
    let pdfBuffer = null; // original raw bytes

    function setActiveTool(name){
      currentTool = name;
      toolButtons.forEach(b=>b.classList.toggle('active', b.dataset.tool === name));
      // cursor changes
      document.querySelectorAll('.annotation-layer').forEach(c=>{
        c.style.cursor = (name === 'pan') ? 'grab' : 'crosshair';
      });
    }

    toolButtons.forEach(btn=>btn.addEventListener('click', ()=>setActiveTool(btn.dataset.tool)));
    setActiveTool('pan');

    // file input
    fileInput.addEventListener('change', async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      filenameEl.textContent = f.name;
      const array = await f.arrayBuffer();
      pdfBuffer = array;
      await loadPdf(array);
    });

    // drag & drop
    ['dragenter','dragover','dragleave','drop'].forEach(ev=>{
      dropzone.addEventListener(ev, (e)=>e.preventDefault());
    });
    dropzone.addEventListener('drop', async (e)=>{
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      if(!f) return;
      filenameEl.textContent = f.name;
      const array = await f.arrayBuffer();
      pdfBuffer = array;
      await loadPdf(array);
    });

    // Load PDF and render pages
    async function loadPdf(arrayBuffer){
      pagesEl.innerHTML = '';
      const loadingTask = pdfjsLib.getDocument({data:arrayBuffer});
      const pdfDoc = await loadingTask.promise;
      const numPages = pdfDoc.numPages;

      for(let i=1;i<=numPages;i++){
        const page = await pdfDoc.getPage(i);
        const viewport = page.getViewport({scale:1.5});
        const scale = 1.5;

        const pageWrap = document.createElement('div');
        pageWrap.className = 'page';
        // container to match intrinsic canvas pixel size
        const canvas = document.createElement('canvas');
        canvas.className = 'pdf-canvas';
        canvas.width = Math.round(viewport.width);
        canvas.height = Math.round(viewport.height);
        const ctx = canvas.getContext('2d');

        const renderContext = {canvasContext:ctx,viewport};
        await page.render(renderContext).promise;

        // annotation canvas overlay
        const ann = document.createElement('canvas');
        ann.className = 'annotation-layer';
        ann.width = canvas.width;
        ann.height = canvas.height;
        ann.style.width = '100%';
        ann.style.height = 'auto';
        ann.dataset.page = i-1;
        ann.style.position = 'absolute';
        ann.style.left = 0; ann.style.top = 0;
        const annCtx = ann.getContext('2d');
        annCtx.lineJoin = 'round';
        annCtx.lineCap = 'round';

        // wrap sizes
        const wrap = document.createElement('div');
        wrap.style.maxWidth = Math.min(900, canvas.width)+'px';
        wrap.style.width = canvas.width+'px';
        wrap.style.position = 'relative';
        wrap.appendChild(canvas);
        wrap.appendChild(ann);

        pageWrap.appendChild(wrap);
        pagesEl.appendChild(pageWrap);

        const pageObj = {pdfPage: page, canvas, ann, annCtx, actions:[], scale, viewport};
        docPages.push(pageObj);

        // wire events for annotations
        bindAnnotationEvents(pageObj);
      }

      emptyState && emptyState.remove();
    }

    // Annotation interactions
    function bindAnnotationEvents(pageObj){
      const {ann, annCtx, canvas} = pageObj;
      let drawing = false;
      let currentPath = null;

      function clientToCanvas(e){
        const rect = ann.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (ann.width / rect.width);
        const y = (e.clientY - rect.top) * (ann.height / rect.height);
        return {x,y};
      }

      function start(e){
        if(currentTool === 'pan') return;
        drawing = true;
        const {x,y} = clientToCanvas(e);
        currentPath = {tool:currentTool,color:colorInput.value, size: parseInt(sizeInput.value,10), points:[{x,y}]};
        annCtx.strokeStyle = currentPath.color;
        annCtx.lineWidth = currentPath.size;
        if(currentTool === 'highlight') annCtx.globalAlpha = 0.35; else annCtx.globalAlpha = 1;
        // draw initial
        annCtx.beginPath();
        annCtx.moveTo(x,y);
      }

      function move(e){
        if(!drawing) return;
        const {x,y} = clientToCanvas(e);
        const last = currentPath.points[currentPath.points.length-1];
        currentPath.points.push({x,y});
        annCtx.lineTo(x,y);
        annCtx.stroke();
      }

      function end(e){
        if(!drawing) return;
        drawing = false;
        annCtx.closePath();
        annCtx.globalAlpha = 1;
        // push to actions for undo
        if(currentPath){
          pageObj.actions.push(currentPath);
          currentPath = null;
        }
      }

      // pointer support
      ann.addEventListener('pointerdown', (e)=>{
        if(currentTool === 'erase'){
          // immediate erase: sample and clear single pixel by drawing clear circle
          const pos = clientToCanvas(e);
          annCtx.clearRect(pos.x-18, pos.y-18, 36, 36);
          // record as action so user can undo by clearing and redrawing - for simplicity we push an erase action
          pageObj.actions.push({tool:'erase',x:pos.x,y:pos.y,w:36});
          return;
        }
        if(currentTool === 'text'){
          const pos = clientToCanvas(e);
          placeTextInputAt(pageObj,pos);
          return;
        }
        start(e);
        ann.setPointerCapture(e.pointerId);
      });

      ann.addEventListener('pointermove', move);
      ann.addEventListener('pointerup', (e)=>{ end(e); ann.releasePointerCapture(e.pointerId); });
      ann.addEventListener('pointerleave', (e)=>{ end(e); });

      // expose helper to redraw from actions
      pageObj.redraw = function(){
        annCtx.clearRect(0,0,ann.width,ann.height);
        for(const a of pageObj.actions){
          if(a.tool === 'erase'){
            annCtx.clearRect(a.x - a.w/2, a.y - a.w/2, a.w, a.w);
            continue;
          }
          annCtx.beginPath();
          annCtx.strokeStyle = a.color;
          annCtx.lineWidth = a.size;
          if(a.tool === 'highlight') annCtx.globalAlpha = 0.35; else annCtx.globalAlpha = 1;
          const pts = a.points;
          annCtx.moveTo(pts[0].x, pts[0].y);
          for(let i=1;i<pts.length;i++) annCtx.lineTo(pts[i].x, pts[i].y);
          annCtx.stroke();
          annCtx.closePath();
          annCtx.globalAlpha = 1;
        }
      }
    }

    // place a text input overlay to capture typed text then render to annotation canvas
    function placeTextInputAt(pageObj,pos){
      const {ann, annCtx, actions} = pageObj;
      // create editable div
      const rect = ann.getBoundingClientRect();
      const scale = ann.width / rect.width;
      const x = pos.x / scale; const y = pos.y / scale; // approximate CSS px -> canvas px

      const input = document.createElement('div');
      input.contentEditable = 'true';
      input.style.position='absolute';
      input.style.left = (pos.x/scale)+'px';
      input.style.top = (pos.y/scale)+'px';
      input.style.minWidth = '120px';
      input.style.minHeight = '24px';
      input.style.background = 'rgba(255,255,255,0.9)';
      input.style.border = '1px dashed rgba(0,0,0,0.12)';
      input.style.padding = '6px';
      input.style.zIndex = 9999;
      input.style.color = colorInput.value;
      input.style.fontSize = Math.max(12, parseInt(sizeInput.value,10)*2)+'px';

      // add to DOM on top of annotation canvas
      ann.parentElement.style.position = 'relative';
      ann.parentElement.appendChild(input);
      input.focus();

      function commit(){
        const text = input.innerText.trim();
        if(text.length){
          // draw text onto annotation canvas
          annCtx.font = input.style.fontSize + ' sans-serif';
          annCtx.fillStyle = colorInput.value;
          annCtx.textBaseline = 'top';
          // convert location: use scaled coordinates
          const drawX = (pos.x/ann.parentElement.getBoundingClientRect().width) * ann.width;
          const drawY = (pos.y/ann.parentElement.getBoundingClientRect().height) * ann.height;
          annCtx.fillText(text, drawX, drawY);
          // record action for undo
          pageObj.actions.push({tool:'text',text,color:colorInput.value,size:input.style.fontSize,x:drawX,y:drawY});
        }
        input.remove();
      }

      input.addEventListener('blur', commit);
      input.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ e.preventDefault(); input.blur(); } });
    }

    // Undo
    undoBtn.addEventListener('click', ()=>{
      // undo last action on the last page with actions
      for(let i = docPages.length - 1; i>=0; i--){
        const p = docPages[i];
        if(p.actions.length){ p.actions.pop(); p.redraw(); return; }
      }
      alert('No actions to undo');
    });

    // Clear page - clears only the first page that has actions (for simplicity)
    clearBtn.addEventListener('click', ()=>{
      // find active page (first with actions) or prompt page number
      const p = docPages[0];
      if(!p) return;
      p.actions = [];
      p.redraw();
    });

    // Save PDF: rasterize each page (base canvas + annotation) to PNG and create a new PDF with those images
    saveBtn.addEventListener('click', async ()=>{
      if(!pdfBuffer){ alert('No PDF loaded'); return; }
      saveBtn.disabled = true; saveBtn.textContent = 'Exporting...';
      try{
        const pdfDoc = await PDFDocument.create();
        for(const p of docPages){
          const merged = await mergePageToImage(p);
          const pngBytes = await (await fetch(merged)).arrayBuffer();
          const img = await pdfDoc.embedPng(pngBytes);
          const page = pdfDoc.addPage([p.viewport.width, p.viewport.height]);
          page.drawImage(img, {x:0,y:0,width:p.viewport.width,height:p.viewport.height});
        }
        const final = await pdfDoc.save();
        const blob = new Blob([final],{type:'application/pdf'});
        const url = URL.createObjectURL(blob);
        triggerDownload(url, 'edited.pdf');
      }catch(err){
        console.error(err); alert('Export failed: '+err.message);
      }finally{ saveBtn.disabled = false; saveBtn.textContent = 'Save PDF'; }
    });

    // Export images (for convenience)
    exportImagesBtn.addEventListener('click', async ()=>{
      for(let i=0;i<docPages.length;i++){
        const p = docPages[i];
        const merged = await mergePageToImage(p);
        triggerDownload(merged, `page-${i+1}.png`);
      }
    });

    function triggerDownload(dataUrl, filename){
      const a = document.createElement('a');
      a.href = dataUrl;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    // merge the base PDF canvas and the annotation canvas into a single data URL (PNG)
    async function mergePageToImage(p){
      const baseCanvas = p.canvas;
      const annCanvas = p.ann;
      // create an offscreen canvas at the same pixel size
      const merge = document.createElement('canvas');
      merge.width = baseCanvas.width;
      merge.height = baseCanvas.height;
      const mctx = merge.getContext('2d');
      // draw base
      mctx.drawImage(baseCanvas,0,0);
      // draw annotation (ann is same size)
      mctx.drawImage(annCanvas,0,0);
      return merge.toDataURL('image/png');
    }

    // Utility: clear everything
    function reset(){ docPages = []; pagesEl.innerHTML = '<div style="text-align:center;color:rgba(0,0,0,0.45);padding:40px" id="emptyState">No PDF loaded — upload or drop a PDF file to get started.</div>'; }

    // initialize
    reset();

  })();
  </script>

<section class="related-tool-callout">
  <h2>Related Tool</h2>
  <p>Already combined your PDFs? You might also need our <a href="/pdf-splitter/">PDF Splitter</a> — quickly separate large documents into individual pages or custom ranges.</p>
</section>

    <!-- Footer Include -->
  <div data-include="/footer.html"></div>

  <!-- Back to Top -->
  <a href="#" class="btn btn-lg btn-primary btn-lg-square rounded-circle back-to-top">
    <i class="bi bi-arrow-up"></i>
  </a>
  <!-- Custom Scripts -->
  <script src="/js/main.js"></script>
  <script>
    document.querySelectorAll('[data-include]').forEach(async el => {
      const file = el.getAttribute('data-include');
      const res = await fetch(file);
      const html = await res.text();
      el.innerHTML = html;

      // Re-initialize WOW animations
      if (typeof WOW === "function") {
        new WOW().init();
      }
    });
  </script>
</body>
</html>
